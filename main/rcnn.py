import numpy as npimport matplotlib.pyplot as plt# import scipyimport rcnn_utils as Uimport torchimport torch.nn as nnfrom torch.autograd import Variableimport torch.nn.functional as Fimport torch.optim as optimfrom torch.utils.data import TensorDataset, DataLoaderfrom statistics import meantorch.manual_seed(0)from torch.utils.data import DataLoaderfrom util import PngDatadataloader = DataLoader(PngData('data/images_original'))for x, y in dataloader:    print(x.shape)    print(y.shape)"""def main():def train():class Net(nn.Module):   def __init__(self):      super(Net, self).__init__()                 self.conv1 = nn.Conv2d(3, 6, 5, 1)      self.pool = nn.AdaptiveMaxPool2d(2,2)      self.conv2 = nn.Conv2d(6, 6, 1, 1)            self.conv3 = nn.Conv2d(6, 6, 1, 1)      self.conv4 = nn.Conv2d(6, 12, 5, 1)      self.pool = nn.AdaptiveMaxPool2d(2,2)            self.fc_1 = nn.Linear(12 * 56 * 56, 120)      self.fc_2 = nn.Linear(120, 64)      self.fc_3 = nn.Linear(64, 2)      self.Sigmoid = nn.Sigmoid()   def forward(self, x):       x = F.relu(self.conv1(x))              x_pre_input = x       x = F.relu(self.conv2(x))        x = F.relu(self.conv3(x))       #residual connection       x = x + x_pre_input       x = F.relu(self.conv4(x))              #flattens tensor       x = x.view(x.size(0), -1) #number of samples in batch       x = F.relu(self.fc_1(x))       x = F.relu(self.fc_2(x))       x = F.sigmoid(self.fc_3(x))                return x """